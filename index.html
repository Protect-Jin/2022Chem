<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í™”í•™ë§›.ZIP ì‹­ìë§í’€ì´ (ì—…ê·¸ë ˆì´ë“œ)</title>
    <style>
        :root { --primary: #2c3e50; --accent: #3498db; --bg: #f8f9fa; --border: #ced4da; --success: #27ae60; }
        * { box-sizing: border-box; }
        body { font-family: 'Pretendard', sans-serif; margin: 0; background: var(--bg); height: 100vh; display: flex; flex-direction: column; }
        
        header { background: var(--primary); color: white; padding: 1rem; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h1 { margin: 0; font-size: 1.4rem; }
        .header-btn { background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; cursor: pointer; border-radius: 4px; font-size: 0.9rem; }

        /* ì§„í–‰ë¥  í‘œì‹œë°” ìŠ¤íƒ€ì¼ */
        #progress-container { width: 100%; height: 8px; background: #e0e0e0; position: relative; }
        #progress-bar { width: 0%; height: 100%; background: var(--success); transition: width 0.4s ease; }

        main { flex: 1; display: flex; overflow: hidden; position: relative; }
        
        #maker-panel {
            position: absolute; top: 0; left: 0; width: 350px; height: 100%; 
            background: white; border-right: 2px solid var(--accent); padding: 20px; 
            z-index: 100; transform: translateX(-100%); transition: transform 0.3s ease;
            box-shadow: 5px 0 15px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 10px;
        }
        #maker-panel.open { transform: translateX(0); }
        textarea { flex: 1; padding: 10px; border: 1px solid var(--border); border-radius: 5px; resize: none; }

        #student-view { flex: 1; display: flex; padding: 20px; gap: 20px; justify-content: center; overflow: hidden; }
        
        #grid-container { 
            flex: 2; display: flex; justify-content: center; align-items: flex-start; 
            overflow: auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        #puzzle-board { display: grid; gap: 1px; background: #333; border: 2px solid #333; }
        .cell { width: 38px; height: 38px; background: white; position: relative; display: flex; justify-content: center; align-items: center; }
        .cell.black { background: #222; }
        .cell input { 
            width: 100%; height: 100%; border: none; text-align: center; 
            font-size: 18px; font-weight: bold; outline: none; background: transparent; 
            color: #333; caret-color: transparent; /* ì»¤ì„œ ìˆ¨ê¹€ìœ¼ë¡œ ë” ê¹”ë”í•˜ê²Œ */
        }
        .cell input:focus { background: #e3f2fd; }
        .cell-num { position: absolute; top: 1px; left: 2px; font-size: 10px; color: #666; pointer-events: none; }
        
        .correct { background-color: #d4edda !important; }
        .wrong { background-color: #f8d7da !important; }
        .revealed { background-color: #ffe0b2 !important; }

        #clues-container { flex: 1; min-width: 300px; max-width: 400px; display: flex; flex-direction: column; gap: 15px; overflow-y: auto; }
        .clue-box { background: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .clue-box h3 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--primary); border-bottom: 2px solid var(--accent); }
        ul { list-style: none; padding: 0; }
        li { padding: 6px 8px; border-bottom: 1px solid #eee; cursor: pointer; font-size: 0.95rem; }
        li:hover { background: #f1f3f5; color: var(--accent); }

        .controls { margin-top: auto; display: flex; gap: 10px; }
        .btn { padding: 12px; border: none; border-radius: 5px; color: white; font-weight: bold; cursor: pointer; flex: 1; }
        .btn-blue { background: var(--accent); }
        .btn-green { background: var(--success); }
        .btn-red { background: #e74c3c; }
        
        @media (max-width: 900px) {
            #student-view { flex-direction: column; overflow-y: auto; }
        }
    </style>
</head>
<body>

<header>
    <h1>ğŸ§ª í™”í•™ë§›.ZIP: ìš°ë¦¬ ì£¼ë³€ì˜ í™”í•™ í‰í˜•</h1>
    <div>
        <button class="header-btn" onclick="toggleMaker()">âš™ï¸ ë¬¸ì œ ë§Œë“¤ê¸° </button>
    </div>
</header>
<div id="progress-container">
    <div id="progress-bar"></div>
</div>

<main>
    <section id="maker-panel">
        <div class="panel-title">ë‹¨ì–´ ë° íŒíŠ¸ ì…ë ¥</div>
        <textarea id="word-input">í™”í•™í‰í˜•|í™”í•™ ë°˜ì‘ì—ì„œ ì •ë°˜ì‘ê³¼ ì—­ë°˜ì‘ ì†ë„ê°€ ê°™ì•„ ê²‰ë³´ê¸°ì— ë³€í™”ê°€ ì—†ëŠ” ìƒíƒœ
ì•”ëª¨ë‹ˆì•„|ì§ˆì†Œì™€ ìˆ˜ì†Œê°€ ë°˜ì‘í•˜ì—¬ ìƒì„±ë˜ëŠ” ë¹„ë£Œì˜ ì›ë£Œ
ìˆ˜ë“ë¥ |ìƒì„±ë¬¼ì˜ ì´ë¡ ì  ìƒì„±ëŸ‰ì— ëŒ€í•œ ì‹¤ì œ ìƒì„±ëŸ‰ì˜ ë¹„ìœ¨
ë¥´ìƒ¤í‹€ë¦¬ì—|í‰í˜• ìƒíƒœì—ì„œ ë³€í™”ë¥¼ ê°ì†Œì‹œí‚¤ë ¤ëŠ” ë°©í–¥ìœ¼ë¡œ ì´ë™í•˜ëŠ” ì›ë¦¬
íƒ„ì‚°ìŒë£Œ|ê³ ì••ì—ì„œ ì´ì‚°í™”íƒ„ì†Œë¥¼ ë¬¼ì— ë…¹ì¸ ìŒë£Œ
í‰í˜•ìƒìˆ˜|ì˜¨ë„ê°€ ì¼ì •í•  ë•Œ ë°˜ì‘ë¬¼ê³¼ ìƒì„±ë¬¼ì˜ ë†ë„ ê³±ì˜ ë¹„
ì •ë°˜ì‘|ë°˜ì‘ë¬¼ì—ì„œ ìƒì„±ë¬¼ë¡œ ì§„í–‰ë˜ëŠ” ë°˜ì‘
ì—­ë°˜ì‘|ìƒì„±ë¬¼ì—ì„œ ë°˜ì‘ë¬¼ë¡œ ì§„í–‰ë˜ëŠ” ë°˜ì‘</textarea>
        <button class="btn btn-blue" onclick="generatePuzzle()">ğŸ”„ í¼ì¦ ìƒì„±í•˜ê¸°</button>
    </section>

    <section id="student-view">
        <div id="grid-container"><div id="puzzle-board"></div></div>
        <div id="clues-container">
            <div class="clue-box"><h3>ê°€ë¡œ ì—´ì‡  â¡</h3><ul id="across-list"></ul></div>
            <div class="clue-box"><h3>ì„¸ë¡œ ì—´ì‡  â¬‡</h3><ul id="down-list"></ul></div>
            <div class="controls">
                <button class="btn btn-green" onclick="checkAnswers()">âœ… ìµœì¢… í™•ì¸</button>
                <button class="btn btn-red" onclick="resetInputs()">ì´ˆê¸°í™”</button>
            </div>
        </div>
    </section>
</main>

<script>
    let gridSize = 20; 
    let grid = [];     
    let placedWords = []; 
    let lastDirection = 'H'; // ë§ˆì§€ë§‰ ì´ë™ ë°©í–¥ ê¸°ì–µ (ì…ë ¥ í›„ ìë™ì´ë™ìš©)

    window.onload = generatePuzzle;

    function toggleMaker() { document.getElementById('maker-panel').classList.toggle('open'); }

    function generatePuzzle() {
        const input = document.getElementById('word-input').value.trim();
        const lines = input.split('\n').filter(l => l.includes('|'));
        let words = lines.map(line => {
            const [w, c] = line.split('|');
            return { word: w.trim(), clue: c.trim(), len: w.trim().length };
        }).sort((a, b) => b.len - a.len);

        grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(null));
        placedWords = [];
        
        // ì²« ë‹¨ì–´ ë°°ì¹˜ ë° ë‚˜ë¨¸ì§€ ë¡œì§ (ê¸°ì¡´ ìœ ì§€)
        if (words.length > 0) placeRandomly(words.shift(), true);
        words.forEach(w => {
            const best = findBestPosition(w);
            if (best) placeOnGrid(w, best.r, best.c, best.dir);
            else placeRandomly(w, false);
        });

        renderBoard();
        renderClues();
        updateProgressBar();
    }

    function placeRandomly(wordObj, isCenter) {
        for(let i=0; i<100; i++) {
            const dir = Math.random() > 0.5 ? 'H' : 'V';
            const r = isCenter ? Math.floor(gridSize/2) : Math.floor(Math.random()*gridSize);
            const c = isCenter ? Math.floor((gridSize-wordObj.len)/2) : Math.floor(Math.random()*gridSize);
            if (canPlace(wordObj.word, r, c, dir)) {
                placeOnGrid(wordObj, r, c, dir);
                return true;
            }
        }
        return false;
    }

    function findBestPosition(wordObj) {
        for (let pw of placedWords) {
            for (let i = 0; i < pw.word.length; i++) {
                for (let j = 0; j < wordObj.word.length; j++) {
                    if (pw.word[i] === wordObj.word[j]) {
                        const dir = pw.dir === 'H' ? 'V' : 'H';
                        const r = dir === 'V' ? pw.r - j : pw.r + i;
                        const c = dir === 'H' ? pw.c - j : pw.c + i;
                        if (canPlace(wordObj.word, r, c, dir)) return { r, c, dir };
                    }
                }
            }
        }
        return null;
    }

    function canPlace(word, r, c, dir) {
        if (r < 0 || c < 0 || (dir === 'H' && c + word.length > gridSize) || (dir === 'V' && r + word.length > gridSize)) return false;
        for (let i = 0; i < word.length; i++) {
            const curR = dir === 'V' ? r + i : r;
            const curC = dir === 'H' ? c + i : c;
            if (grid[curR][curC] && grid[curR][curC] !== word[i]) return false;
        }
        return true;
    }

    function placeOnGrid(wordObj, r, c, dir) {
        for (let i = 0; i < wordObj.word.length; i++) {
            grid[dir === 'V' ? r + i : r][dir === 'H' ? c + i : c] = wordObj.word[i];
        }
        placedWords.push({ ...wordObj, r, c, dir });
    }

    function renderBoard() {
        const board = document.getElementById('puzzle-board');
        board.style.gridTemplateColumns = `repeat(${gridSize}, 38px)`;
        board.innerHTML = '';
        let numberMap = {};
        let numCounter = 1;
        
        placedWords.sort((a,b) => (a.r*gridSize + a.c) - (b.r*gridSize + b.c));
        placedWords.forEach(pw => {
            if (!numberMap[`${pw.r},${pw.c}`]) numberMap[`${pw.r},${pw.c}`] = numCounter++;
            pw.num = numberMap[`${pw.r},${pw.c}`];
        });

        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                const cellVal = grid[r][c];
                const div = document.createElement('div');
                div.className = 'cell' + (cellVal ? '' : ' black');
                if (cellVal) {
                    const input = document.createElement('input');
                    input.maxLength = 1; // í•œ ê¸€ìë§Œ!
                    input.dataset.answer = cellVal;
                    input.id = `input-${r}-${c}`;
                    input.onkeydown = (e) => handleKey(e, r, c);
                    input.oninput = (e) => handleInput(e, r, c);
                    input.onclick = function() { if(this.parentElement.classList.contains('wrong')) revealChar(this); };
                    if (numberMap[`${r},${c}`]) {
                        const num = document.createElement('span');
                        num.className = 'cell-num';
                        num.innerText = numberMap[`${r},${c}`];
                        div.appendChild(num);
                    }
                    div.appendChild(input);
                }
                board.appendChild(div);
            }
        }
    }

    // [í•µì‹¬ ì—…ë°ì´íŠ¸] ì…ë ¥ í•¸ë“¤ëŸ¬
    function handleInput(e, r, c) {
        if (e.target.value.length > 0) {
            // ì…ë ¥ ì‹œ ìƒ‰ìƒ ì´ˆê¸°í™”
            e.target.parentElement.classList.remove('wrong', 'correct');
            
            // ë‹¤ìŒ ì¹¸ ì°¾ê¸° (í˜„ì¬ ì´ë™ ë°©í–¥ ìš°ì„ )
            let nextR = r, nextC = c;
            if (lastDirection === 'H') nextC++;
            else nextR++;

            const nextEl = document.getElementById(`input-${nextR}-${nextC}`);
            if (nextEl) nextEl.focus();
            
            updateProgressBar();
        }
    }

    // [í•µì‹¬ ì—…ë°ì´íŠ¸] í‚¤ë³´ë“œ í•¸ë“¤ëŸ¬
    function handleKey(e, r, c) {
        if (e.key === 'ArrowRight') { focusCell(r, c + 1); lastDirection = 'H'; }
        else if (e.key === 'ArrowLeft') { focusCell(r, c - 1); lastDirection = 'H'; }
        else if (e.key === 'ArrowDown') { focusCell(r + 1, c); lastDirection = 'V'; }
        else if (e.key === 'ArrowUp') { focusCell(r - 1, c); lastDirection = 'V'; }
        else if (e.key === 'Backspace' && e.target.value === '') {
            if (lastDirection === 'H') focusCell(r, c - 1);
            else focusCell(r - 1, c);
        }
    }

    function focusCell(r, c) {
        const el = document.getElementById(`input-${r}-${c}`);
        if (el) el.focus();
    }

    // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateProgressBar() {
        const inputs = document.querySelectorAll('.cell input');
        let filledCorrect = 0;
        inputs.forEach(input => {
            if (input.value === input.dataset.answer) filledCorrect++;
        });
        const percent = inputs.length > 0 ? (filledCorrect / inputs.length) * 100 : 0;
        document.getElementById('progress-bar').style.width = percent + '%';
    }

    function checkAnswers() {
        const inputs = document.querySelectorAll('.cell input');
        inputs.forEach(input => {
            if (input.value === input.dataset.answer) input.parentElement.classList.add('correct');
            else if (input.value !== '') input.parentElement.classList.add('wrong');
        });
        updateProgressBar();
    }

    function resetInputs() {
        if(confirm("ëª¨ë‘ ì§€ìš¸ê¹Œìš”?")) {
            document.querySelectorAll('.cell input').forEach(i => {
                i.value = '';
                i.parentElement.classList.remove('correct', 'wrong', 'revealed');
            });
            updateProgressBar();
        }
    }

    function renderClues() {
        const aList = document.getElementById('across-list');
        const dList = document.getElementById('down-list');
        aList.innerHTML = dList.innerHTML = '';
        placedWords.sort((a,b) => a.num - b.num).forEach(pw => {
            const li = document.createElement('li');
            li.innerHTML = `<b>${pw.num}.</b> ${pw.clue}`;
            li.onclick = () => {
                lastDirection = pw.dir; // í´ë¦­í•œ íŒíŠ¸ ë°©í–¥ìœ¼ë¡œ ìë™ì´ë™ ì„¤ì •
                document.getElementById(`input-${pw.r}-${pw.c}`).focus();
            };
            if (pw.dir === 'H') aList.appendChild(li);
            else dList.appendChild(li);
        });
    }

    function revealChar(inputEl) {
        if (confirm("ì •ë‹µì„ í™•ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
            inputEl.value = inputEl.dataset.answer;
            inputEl.parentElement.classList.replace('wrong', 'revealed');
            updateProgressBar();
        }
    }
</script>
</body>
</html>
