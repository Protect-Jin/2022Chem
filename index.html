ì™„ë²½í•©ë‹ˆë‹¤! ë§ˆì§€ë§‰ìœ¼ë¡œ í•™ìƒë“¤ì˜ ê²°ê³¼ë¬¼ì„ ê°„ì§í•˜ê±°ë‚˜ ê³¼ì œë¡œ ì œì¶œí•  ìˆ˜ ìˆê²Œ [ì´ë¯¸ì§€ ì €ì¥] ê¸°ëŠ¥ì„ ì¶”ê°€í•´ ë³¼ê²Œìš”.

ì›¹ í™”ë©´ì„ ê·¸ëŒ€ë¡œ ìº¡ì²˜í•˜ê¸° ìœ„í•´ì„œëŠ” html2canvasë¼ëŠ” ìœ ëª…í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ê°€ì¥ ê¹”ë”í•©ë‹ˆë‹¤. ì´ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ê¸° ìœ„í•´ ì½”ë“œ ìƒë‹¨ì— ìŠ¤í¬ë¦½íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤„ì„ ë„£ê³ , í•˜ë‹¨ ì»¨íŠ¸ë¡¤ ë°”ì— ë²„íŠ¼ì„ ë°°ì¹˜í–ˆìŠµë‹ˆë‹¤.

ğŸ§ª í™”í•™ë§›.ZIP ìµœì¢…ë³¸ (ì´ë¯¸ì§€ ë‚´ë³´ë‚´ê¸° ê¸°ëŠ¥ ì¶”ê°€)
ì•„ë˜ ì½”ë“œë¥¼ ë³µì‚¬í•´ì„œ ì‚¬ìš©í•˜ì‹œë©´ ë©ë‹ˆë‹¤.

HTML
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í™”í•™ë§›.ZIP ì‹­ìë§í’€ì´</title>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        :root { --primary: #2c3e50; --accent: #3498db; --bg: #f8f9fa; --border: #ced4da; --success: #27ae60; }
        * { box-sizing: border-box; }
        body { font-family: 'Pretendard', sans-serif; margin: 0; background: var(--bg); height: 100vh; display: flex; flex-direction: column; }
        
        header { background: var(--primary); color: white; padding: 1rem; display: flex; justify-content: space-between; align-items: center; }
        h1 { margin: 0; font-size: 1.4rem; }
        
        #progress-wrapper { background: #eee; padding: 5px 20px; display: flex; align-items: center; gap: 15px; border-bottom: 2px solid #ddd; }
        #progress-container { flex: 1; height: 15px; background: #ddd; border-radius: 10px; overflow: hidden; position: relative; }
        #progress-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #2ecc71, #27ae60); transition: width 0.3s ease; }
        #progress-text { font-weight: bold; color: var(--primary); min-width: 80px; text-align: right; }

        /* ìº¡ì²˜ ëŒ€ìƒ ì˜ì—­ */
        #capture-area { flex: 1; display: flex; overflow: hidden; background: var(--bg); }

        main { flex: 1; display: flex; overflow: hidden; position: relative; }
        
        #maker-panel {
            position: absolute; top: 0; left: 0; width: 350px; height: 100%; 
            background: white; border-right: 2px solid var(--accent); padding: 20px; 
            z-index: 100; transform: translateX(-100%); transition: transform 0.3s ease;
            box-shadow: 5px 0 15px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 10px;
        }
        #maker-panel.open { transform: translateX(0); }
        textarea { flex: 1; padding: 10px; border: 1px solid var(--border); border-radius: 5px; resize: none; font-size: 14px; }

        #student-view { flex: 1; display: flex; padding: 20px; gap: 20px; justify-content: center; overflow: hidden; }
        #grid-container { flex: 2; display: flex; justify-content: center; align-items: flex-start; overflow: auto; background: white; padding: 20px; border-radius: 10px; }
        #puzzle-board { display: grid; gap: 1px; background: #333; border: 2px solid #333; }
        
        .cell { width: 42px; height: 42px; background: white; position: relative; display: flex; justify-content: center; align-items: center; }
        .cell.black { background: #222; }
        .cell input { width: 100%; height: 100%; border: none; text-align: center; font-size: 20px; font-weight: bold; outline: none; background: transparent; }
        .cell-num { position: absolute; top: 1px; left: 2px; font-size: 10px; color: #666; pointer-events: none; }
        
        .correct { background-color: #d4edda !important; }
        .wrong { background-color: #f8d7da !important; }
        .revealed { background-color: #ffe0b2 !important; }

        #clues-container { flex: 1; min-width: 320px; max-width: 400px; display: flex; flex-direction: column; gap: 15px; overflow-y: auto; }
        .clue-box { background: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .clue-box h3 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--primary); border-bottom: 2px solid var(--accent); }
        ul { list-style: none; padding: 0; }
        li { padding: 8px; border-bottom: 1px solid #eee; cursor: pointer; font-size: 0.95rem; }

        .controls { margin-top: auto; display: flex; flex-wrap: wrap; gap: 10px; }
        .btn { padding: 12px; border: none; border-radius: 5px; color: white; font-weight: bold; cursor: pointer; flex: 1; min-width: 100px; }
        .btn-blue { background: var(--accent); }
        .btn-green { background: var(--success); }
        .btn-red { background: #e74c3c; }
        .btn-purple { background: #9b59b6; } /* ë‚´ë³´ë‚´ê¸° ë²„íŠ¼ ìƒ‰ìƒ */

        @media (max-width: 900px) { #student-view { flex-direction: column; overflow-y: auto; } }
    </style>
</head>
<body>

<header>
    <h1>ğŸ§ª í™”í•™ë§›.ZIP: ìš°ë¦¬ ì£¼ë³€ì˜ í™”í•™ í‰í˜•</h1>
    <button class="btn-blue" style="padding: 5px 10px; font-size: 0.8rem;" onclick="toggleMaker()">âš™ï¸ ë¬¸ì œ í¸ì§‘</button>
</header>

<div id="progress-wrapper">
    <span>ğŸ’¡ ì „ì²´ ì§„í–‰ë„:</span>
    <div id="progress-container"><div id="progress-bar"></div></div>
    <div id="progress-text">0 / 0 (0%)</div>
</div>

<main id="capture-area"> <section id="maker-panel">
        <div style="font-weight:bold;">ë‹¨ì–´|íŒíŠ¸ ì…ë ¥</div>
        <textarea id="word-input">í™”í•™í‰í˜•|í™”í•™ ë°˜ì‘ì—ì„œ ì •ë°˜ì‘ê³¼ ì—­ë°˜ì‘ ì†ë„ê°€ ê°™ì•„ ê²‰ë³´ê¸°ì— ë³€í™”ê°€ ì—†ëŠ” ìƒíƒœ
ì•”ëª¨ë‹ˆì•„|ì§ˆì†Œì™€ ìˆ˜ì†Œê°€ ë°˜ì‘í•˜ì—¬ ìƒì„±ë˜ëŠ” ë¹„ë£Œì˜ ì›ë£Œ
ìˆ˜ë“ë¥ |ìƒì„±ë¬¼ì˜ ì´ë¡ ì  ìƒì„±ëŸ‰ì— ëŒ€í•œ ì‹¤ì œ ìƒì„±ëŸ‰ì˜ ë¹„ìœ¨
ë¥´ìƒ¤í‹€ë¦¬ì—|í‰í˜• ìƒíƒœì—ì„œ ë³€í™”ë¥¼ ê°ì†Œì‹œí‚¤ë ¤ëŠ” ë°©í–¥ìœ¼ë¡œ ì´ë™í•˜ëŠ” ì›ë¦¬
íƒ„ì‚°ìŒë£Œ|ê³ ì••ì—ì„œ ì´ì‚°í™”íƒ„ì†Œë¥¼ ë¬¼ì— ë…¹ì¸ ìŒë£Œ
í‰í˜•ìƒìˆ˜|ì˜¨ë„ê°€ ì¼ì •í•  ë•Œ ë°˜ì‘ë¬¼ê³¼ ìƒì„±ë¬¼ì˜ ë†ë„ ê³±ì˜ ë¹„
ì •ë°˜ì‘|ë°˜ì‘ë¬¼ì—ì„œ ìƒì„±ë¬¼ë¡œ ì§„í–‰ë˜ëŠ” ë°˜ì‘
ì—­ë°˜ì‘|ìƒì„±ë¬¼ì—ì„œ ë°˜ì‘ë¬¼ë¡œ ì§„í–‰ë˜ëŠ” ë°˜ì‘
í—¤ëª¨ê¸€ë¡œë¹ˆ|í˜ˆì•¡ ì†ì—ì„œ ì‚°ì†Œë¥¼ ìš´ë°˜í•˜ëŠ” ë‹¨ë°±ì§ˆ</textarea>
        <button class="btn btn-blue" onclick="generatePuzzle()">ğŸ”„ í¼ì¦ ìƒˆë¡œê³ ì¹¨</button>
    </section>

    <section id="student-view">
        <div id="grid-container"><div id="puzzle-board"></div></div>
        <div id="clues-container">
            <div class="clue-box"><h3>ê°€ë¡œ ì—´ì‡  â¡</h3><ul id="across-list"></ul></div>
            <div class="clue-box"><h3>ì„¸ë¡œ ì—´ì‡  â¬‡</h3><ul id="down-list"></ul></div>
            <div class="controls">
                <button class="btn btn-green" onclick="checkAnswers()">âœ… ì •ë‹µ í™•ì¸</button>
                <button class="btn btn-purple" onclick="exportImage()">ğŸ“¸ ì´ë¯¸ì§€ ì €ì¥</button>
                <button class="btn btn-red" onclick="resetInputs()">ì§€ìš°ê¸°</button>
            </div>
        </div>
    </section>
</main>

<script>
    let gridSize = 18; 
    let grid = [];     
    let placedWords = []; 
    let lastDirection = 'H';

    window.onload = generatePuzzle;

    function toggleMaker() { document.getElementById('maker-panel').classList.toggle('open'); }

    // [ë‚´ë³´ë‚´ê¸° ê¸°ëŠ¥] ì´ë¯¸ì§€ ì €ì¥ í•¨ìˆ˜
    function exportImage() {
        const area = document.getElementById('capture-area');
        const originalShadow = area.style.boxShadow;
        area.style.boxShadow = "none"; // ìº¡ì²˜ ì‹œ ê·¸ë¦¼ì ì œê±°

        html2canvas(area, {
            backgroundColor: "#f8f9fa",
            scale: 2, // ê³ í•´ìƒë„ ì €ì¥
            useCORS: true
        }).then(canvas => {
            const link = document.createElement('a');
            link.download = `í™”í•™ë§›_ZIP_ê²°ê³¼_${new Date().toLocaleDateString()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            area.style.boxShadow = originalShadow;
        });
    }

    // --- ê¸°ì¡´ ë¡œì§ë“¤ (í•œê¸€ ìµœì í™” ë° ì§„í–‰ë¥  í¬í•¨) ---
    function generatePuzzle() {
        const input = document.getElementById('word-input').value.trim();
        const lines = input.split('\n').filter(l => l.includes('|'));
        let words = lines.map(line => {
            const [w, c] = line.split('|');
            return { word: w.trim(), clue: c.trim(), len: w.trim().length };
        }).sort((a, b) => b.len - a.len);
        grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(null));
        placedWords = [];
        if (words.length > 0) placeRandomly(words.shift(), true);
        words.forEach(w => {
            const best = findBestPosition(w);
            if (best) placeOnGrid(w, best.r, best.c, best.dir);
            else placeRandomly(w, false);
        });
        renderBoard();
        renderClues();
        updateProgress();
    }

    function placeRandomly(wordObj, isCenter) {
        for(let i=0; i<100; i++) {
            const dir = Math.random() > 0.5 ? 'H' : 'V';
            const r = isCenter ? Math.floor(gridSize/2) : Math.floor(Math.random()*gridSize);
            const c = isCenter ? Math.floor((gridSize-wordObj.len)/2) : Math.floor(Math.random()*gridSize);
            if (canPlace(wordObj.word, r, c, dir)) { placeOnGrid(wordObj, r, c, dir); return true; }
        }
        return false;
    }

    function findBestPosition(wordObj) {
        for (let pw of placedWords) {
            for (let i = 0; i < pw.word.length; i++) {
                for (let j = 0; j < wordObj.word.length; j++) {
                    if (pw.word[i] === wordObj.word[j]) {
                        const dir = pw.dir === 'H' ? 'V' : 'H';
                        const r = dir === 'V' ? pw.r - j : pw.r + i;
                        const c = dir === 'H' ? pw.c - j : pw.c + i;
                        if (canPlace(wordObj.word, r, c, dir)) return { r, c, dir };
                    }
                }
            }
        }
        return null;
    }

    function canPlace(word, r, c, dir) {
        if (r < 0 || c < 0 || (dir === 'H' && c + word.length > gridSize) || (dir === 'V' && r + word.length > gridSize)) return false;
        for (let i = 0; i < word.length; i++) {
            const curR = dir === 'V' ? r + i : r;
            const curC = dir === 'H' ? c + i : c;
            if (grid[curR][curC] && grid[curR][curC] !== word[i]) return false;
        }
        return true;
    }

    function placeOnGrid(wordObj, r, c, dir) {
        for (let i = 0; i < wordObj.word.length; i++) {
            grid[dir === 'V' ? r + i : r][dir === 'H' ? c + i : c] = wordObj.word[i];
        }
        placedWords.push({ ...wordObj, r, c, dir });
    }

    function renderBoard() {
        const board = document.getElementById('puzzle-board');
        board.style.gridTemplateColumns = `repeat(${gridSize}, 42px)`;
        board.innerHTML = '';
        let numberMap = {};
        let numCounter = 1;
        placedWords.sort((a,b) => (a.r*gridSize + a.c) - (b.r*gridSize + b.c));
        placedWords.forEach(pw => {
            if (!numberMap[`${pw.r},${pw.c}`]) numberMap[`${pw.r},${pw.c}`] = numCounter++;
            pw.num = numberMap[`${pw.r},${pw.c}`];
        });
        for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
                const cellVal = grid[r][c];
                const div = document.createElement('div');
                div.className = 'cell' + (cellVal ? '' : ' black');
                if (cellVal) {
                    const input = document.createElement('input');
                    input.dataset.answer = cellVal;
                    input.id = `input-${r}-${c}`;
                    input.oninput = (e) => handleInput(e, r, c);
                    input.onkeydown = (e) => handleKey(e, r, c);
                    input.onclick = function() { if(this.parentElement.classList.contains('wrong')) revealChar(this); };
                    if (numberMap[`${r},${c}`]) {
                        const num = document.createElement('span');
                        num.className = 'cell-num';
                        num.innerText = numberMap[`${r},${c}`];
                        div.appendChild(num);
                    }
                    div.appendChild(input);
                }
                board.appendChild(div);
            }
        }
    }

    function handleInput(e, r, c) {
        const input = e.target;
        input.parentElement.classList.remove('wrong', 'correct');
        if (input.value.length >= 2) {
            const currentVal = input.value[0];
            const nextVal = input.value.substring(1);
            input.value = currentVal; 
            let nextR = r, nextC = c;
            if (lastDirection === 'H') nextC++;
            else nextR++;
            const nextInput = document.getElementById(`input-${nextR}-${nextC}`);
            if (nextInput) {
                nextInput.focus();
                nextInput.value = nextVal;
                handleInput({ target: nextInput }, nextR, nextC);
            }
        }
        updateProgress();
    }

    function handleKey(e, r, c) {
        if (e.key === 'ArrowRight') { focusCell(r, c + 1); lastDirection = 'H'; }
        else if (e.key === 'ArrowLeft') { focusCell(r, c - 1); lastDirection = 'H'; }
        else if (e.key === 'ArrowDown') { focusCell(r + 1, c); lastDirection = 'V'; }
        else if (e.key === 'ArrowUp') { focusCell(r - 1, c); lastDirection = 'V'; }
        else if (e.key === 'Backspace' && e.target.value === '') {
            if (lastDirection === 'H') focusCell(r, c - 1);
            else focusCell(r - 1, c);
        }
    }

    function focusCell(r, c) {
        const el = document.getElementById(`input-${r}-${c}`);
        if (el) { el.focus(); return true; }
        return false;
    }

    function updateProgress() {
        const inputs = document.querySelectorAll('.cell input');
        let correctCount = 0;
        inputs.forEach(input => {
            if (input.value === input.dataset.answer) correctCount++;
        });
        const total = inputs.length;
        const percent = total > 0 ? Math.floor((correctCount / total) * 100) : 0;
        document.getElementById('progress-bar').style.width = percent + '%';
        document.getElementById('progress-text').innerText = `${correctCount} / ${total} (${percent}%)`;
    }

    function checkAnswers() {
        document.querySelectorAll('.cell input').forEach(input => {
            if (input.value === input.dataset.answer) input.parentElement.classList.add('correct');
            else if (input.value !== '') input.parentElement.classList.add('wrong');
        });
        updateProgress();
    }

    function resetInputs() {
        if(confirm("ëª¨ë‘ ì§€ìš¸ê¹Œìš”?")) {
            document.querySelectorAll('.cell input').forEach(i => {
                i.value = '';
                i.parentElement.classList.remove('correct', 'wrong', 'revealed');
            });
            updateProgress();
        }
    }

    function renderClues() {
        const aList = document.getElementById('across-list');
        const dList = document.getElementById('down-list');
        aList.innerHTML = dList.innerHTML = '';
        placedWords.sort((a,b) => a.num - b.num).forEach(pw => {
            const li = document.createElement('li');
            li.innerHTML = `<b>${pw.num}.</b> ${pw.clue} (${pw.word.length}ê¸€ì)`;
            li.onclick = () => { lastDirection = pw.dir; focusCell(pw.r, pw.c); };
            if (pw.dir === 'H') aList.appendChild(li);
            else dList.appendChild(li);
        });
    }

    function revealChar(inputEl) {
        if (confirm("ì´ ì¹¸ì˜ ì •ë‹µì„ í™•ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
            inputEl.value = inputEl.dataset.answer;
            inputEl.parentElement.classList.replace('wrong', 'revealed');
            updateProgress();
        }
    }
</script>
</body>
</html>
